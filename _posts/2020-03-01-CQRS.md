---
layout: post
title: "Command query responsibility segregation"
categories: CQRS
---

In this article, you will find information on:
* Command query responsibility segregation (CQRS) and how you can apply it in Spring Boot application.

# Introduction
According to [Wikipedia](https://en.wikipedia.org/wiki/Command%E2%80%93query_separation)

> Commandâ€“query separation (CQS) is a principle of imperative computer programming [...]
> It states that every method should either be a command that performs an action, or a query that returns data to the caller, but not both. In other words, Asking a question should not change the answer.

[CQRS](https://en.wikipedia.org/wiki/Command%E2%80%93query_separation#Command_query_responsibility_segregation)

> Command query responsibility segregation (CQRS) applies the CQS principle by using separate Query and Command objects to retrieve and modify data, respectively.

CQRS pattern is often used with [Event sourcing architecture](https://en.wikipedia.org/wiki/Event-driven_architecture)

# Implementation of Command 

We can define all Commands as objects which implements interface below: 
```java
public interface Command<INPUT, RESULT> {
    RESULT execute(INPUT input);
}
```

Example implementation of `command` can look like:
```java
@Component
@RequiredArgsConstructor
public class CreateAccountCommand 
  implements Command<Account, Result<Error, Account>> {

    private final AccountRepository accountRepository;

    @Transactional
    public Result<Error, Account> execute(Account account) {
        return accountRepository.findById(account.getId())
                .map(a -> Result.fail(a, Error.ACCOUNT_ALREADY_EXIST))
                .orElseGet(() -> Result.ok(accountRepository.save(account)));
    }

    public enum Error {
        ACCOUNT_ALREADY_EXIST
    }

}
```

# Implementation of Query
 
We can define all `query` as objects which implements interface below (almost the same as `command`):
```java
public interface Query<INPUT, RESULT> {

    RESULT execute(INPUT input);

}
```

Example of implementation can look like:

```java
@Component
@RequiredArgsConstructor
public class GetAccountQuery 
  implements Query<AccountId, Result<Error, Account>> {

    private final AccountRepository accountRepository;

    @Transactional(readOnly = true)
    public Result<Error, Account> execute(AccountId accountId) {
        return accountRepository.findById(accountId)
                .map(Result::<Error, Account>ok)
                .orElse(Result.fail(Error.ACCOUNT_NOT_FOUND));
    }

    public enum Error {
        ACCOUNT_NOT_FOUND
    }
}
```

# Advantages of usage of CQRS

* By using CQRS you have a clear separation between read and write operations. For example read-only database transactions you mark as read-only. E.g. by using annotation `@Transactional(readOnly = true)`,
* All operations are separated that fit to [Single responsibility principle](https://en.wikipedia.org/wiki/Single-responsibility_principle).
* When performance is critical, with CQRS, you can optimize read and write sides independently,
* CQRS may simplify understanding of domain by dividing problem into the command and query parts,
* It is possible to parallelize development and use two teams: one for read and one for write operations.
* When you already use the Event Sourcing, it combines nicely with CQRS.

# Disadvantage of using CQRS 
* I think that [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) application type can be too simple to use `CQRS`.

# Summary
`CQRS` is a nice alternative to organize code. It doesn't need to be used, but can, with [event sourcing architecture](https://en.wikipedia.org/wiki/Event-driven_architecture).
Even simple usage can make our code cleaner. 