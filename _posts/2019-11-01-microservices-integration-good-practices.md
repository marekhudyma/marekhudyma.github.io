---
layout: post
title: "Microservices integration good practices"
categories: microservices
---

In this article, you will find information on:
* good practices during microservice integration. 

In this article I would concentrate on synchronous HTTP communication and asynchronous communication like Kafka, SQS. 

# Introduction
The IT industry moved into microservice architecture.
InfoQ publish opinionated view about adoption rate of many technologies.
In the architecture and design for 2019 Q1 we can see that microservice are used by `Late majority` - it means `80-90%` of people. 
In the same diagram you can see that only `Early Adopters` do  `Correctly build distributted system `.
 
<figure>
  <img src="/assets/2019-11-01-microservices-integration-good-practices/architecture_trend_2019.jpg" alt="Architecture trend for 2019.Q1"> 
  <figcaption>source: https://www.infoq.com/articles/architecture-trends-2019/</figcaption>
</figure>
 
I see a lot of people struggle with basic mechanism of communication of microservices. 








We sacrificed simplicity of monolithical architecture for scalability.
<figure>
  <img src="/assets/2019-11-01-microservices-integration-good-practices/http_communication_problems.png" alt="Http timeout problems"> 
  <figcaption>Http timeout problems</figcaption>
</figure>

In this article you will find set of good practices how microservices should communicate. 

# Monitoring
Whatever you do synchronous or asynchronous communication, you should make a proper monitoring at least of most important indicators:
* How many times do you try communicate with other service, 
* How much time does successful / unsuccessful communication takes (remember that average time is not so meaningful, maybe you want to see 90%, 99% etc. ) 
* If you are a server, try to know your clients and measure load generated by them.

# Asynchronous communication  
Whenever it is possible, use asynchronous communication between services. You can use queues / topics. 

Advantages:
* You eliminate a lot of problems with synchronous communication like: timeouts, internal server error, etc. 
* If your service cannot handle a big traffic, you can consume events in the speed that is appropriate for your service. 

Disadvantages:
* You need to prepare system for deduplication of messages. It can happen that the same message will be provided more than once.  
* You need to guarantee delivery of asynchronous message. In many situations you can end up with [two phase commit problem](https://en.wikipedia.org/wiki/Two-phase_commit_protocol), for example: write something in DB and emit event.

# Asynchronous communication and two phase commit example 

# Synchronous HTTP communication 
In most cases you need to response synchronousy, for example frontend applications need to display something immediately. This communication provide many problems.
Your HTTP requests can be unsuccessful because of many reasons: 
* Http timeout - in this case we are not sure what happened: maybe server was not able to process request or server processed the request but we didn't receive response. 
* Server internal error - server may fail because of our request (and retry of the request will not help) or because temporary problems of service. 

<figure>
  <img src="/assets/2019-11-01-microservices-integration-good-practices/monolith-vs-microservices.png" alt="Monolith vs microservices"> 
  <figcaption>Monolith vs microservices</figcaption>
</figure>










# Idempotency
When we send the request and receive timeout, we are not sure what happened. Maybe we got temporary network problem, maybe server was just too slow. 
The natural solution would be retry of action. In this case server need to be ready for it (I don't want to send the email twice or buy two items in the shop).
Server need to be able to discover that given request has been made in the past and return: 
* http status that will let us know about it, personally return `409 Conflict` because it tells me that given entity already exists. If you can find a better code it is fine. Just make sure to document it in your contract documentation (e.g. Swagger)
* body the same as for successful request, so the client is able to read returned values. 

# Retry 
When the request was not successful, retry can be a natural solution. With retry mechanism you need to be careful. It is not a golden hammer. 
Imagine that server has a performance problem. By retrying you can make situation even worse.
Also think about retry strategy. Maybe you want to retry in the same time intervals or with exponential intervals. 
Another question is how many times you should retry?

# Circuit breaker


# SAGA pattern 
# SEDA 

throtling 
monitoring 
