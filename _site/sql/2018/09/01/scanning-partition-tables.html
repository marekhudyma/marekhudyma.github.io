<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Scanning partitioned tables in PostgreSQL 10 | Marek Hudyma’s blog</title>
<meta name="generator" content="Jekyll v3.8.4" />
<meta property="og:title" content="Scanning partitioned tables in PostgreSQL 10" />
<meta name="author" content="Marek Hudyma" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In this article, you will find information on: How to scan partitioned tables in Postgres using function now()." />
<meta property="og:description" content="In this article, you will find information on: How to scan partitioned tables in Postgres using function now()." />
<link rel="canonical" href="http://localhost:4000/sql/2018/09/01/scanning-partition-tables.html" />
<meta property="og:url" content="http://localhost:4000/sql/2018/09/01/scanning-partition-tables.html" />
<meta property="og:site_name" content="Marek Hudyma’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-09-01T00:00:00+02:00" />
<script type="application/ld+json">
{"description":"In this article, you will find information on: How to scan partitioned tables in Postgres using function now().","author":{"@type":"Person","name":"Marek Hudyma"},"@type":"BlogPosting","url":"http://localhost:4000/sql/2018/09/01/scanning-partition-tables.html","headline":"Scanning partitioned tables in PostgreSQL 10","dateModified":"2018-09-01T00:00:00+02:00","datePublished":"2018-09-01T00:00:00+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/sql/2018/09/01/scanning-partition-tables.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Marek Hudyma's blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Marek Hudyma&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Scanning partitioned tables in PostgreSQL 10</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-09-01T00:00:00+02:00" itemprop="datePublished">2018-09-01
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>In this article, you will find information on:</p>
<ul>
  <li>How to scan partitioned tables in Postgres using function <code class="highlighter-rouge">now()</code>.</li>
</ul>

<h1 id="scanning-partitioned-tables">Scanning partitioned tables</h1>
<p>In my application, I wanted to get rows older than the current time. 
I executed the explain plan for the query and I realized that the execution plan did not eliminate unnecessary partitions:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EXPLAIN SELECT * FROM transactions WHERE created &lt; now();  -- it is 2018-08-01
</code></pre></div></div>
<figure>
  <img src="/assets/2018-09-01-scanning-partition-tables/execution_plan_now.png" alt="Execution plan for now function" /> 
  <figcaption>not optimal execution plan</figcaption>
</figure>

<p>I was surprised that DB didn’t make this query optimal. Execution with the hardcoded value returned optimal execution plan:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EXPLAIN SELECT * FROM transactions WHERE created &lt; '2018-01-01 00:00:00'
</code></pre></div></div>
<figure>
  <img src="/assets/2018-09-01-scanning-partition-tables/execution_plan_static_date.png" alt="Execution plan for static date" /> 
  <figcaption>optimal execution plan</figcaption>
</figure>

<p>The reason is that function <code class="highlighter-rouge">now()</code> is not immutable. 
Constant values for the timestamps in the WHERE clause of the query work as expected but if the comparison is against a non-immutable function (such as now(), current_time, current_date, clock_timestamp(), etc.) then the query optimizer won’t be able to narrow down the scan to the relevant partitions, since it doesn’t know in which one the function value will fall into at runtime. It will, therefore, fall back to a full scan of all partitions removing the benefit of partitioning.</p>

<p>With this knowledge, I defined the function that returns <code class="highlighter-rouge">immutable now</code> :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE FUNCTION immutable_now() RETURNS  TIMESTAMP WITH TIME ZONE AS $$
    SELECT now();
$$ LANGUAGE sql IMMUTABLE;
</code></pre></div></div>
<p>It seemed to work correctly! Rows were returned correctly, but suddenly it stopped returning newer rows.
The reason is that PostgreSQL started to <code class="highlighter-rouge">cache the results of the immutable_now</code> function.</p>
<figure>
  <img src="/assets/2018-09-01-scanning-partition-tables/flow_diagram.png" alt="Flow diagram" /> 
  <figcaption>PostgreSQL started to cache the result of the immutable_now function.</figcaption>
</figure>

<h1 id="reason">Reason</h1>
<p>Documentation on <a href="https://www.postgresql.org/docs/current/static/sql-createfunction.html">function immutability</a>:
<em>“IMMUTABLE indicates that the function […] always returns the same result when given the same argument values; that is, it does not […] use information not directly present in its argument list. If this option is given, any call of the function with all-constant arguments can be immediately replaced with the function value.”</em>
`
and again in the documentation on function <a href="https://www.postgresql.org/docs/current/static/xfunc-volatility.html">volatility categories</a>
<em>“Labeling a function IMMUTABLE when it really isn’t might allow it to be prematurely folded to a constant during planning, resulting in a stale value being re-used during subsequent uses of the plan. This is a hazard when using […] function languages that cache plans (such as PL/pgSQL).”</em></p>

<h1 id="solution">Solution</h1>
<p>The solution was to add random UUID as an argument, that will be ignored. PostgreSQL will not cache this function:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE FUNCTION immutable_now(ignored uuid) RETURNS TIMESTAMP WITH TIME ZONE AS 
$$
    SELECT now();
$$ LANGUAGE sql IMMUTABLE;
</code></pre></div></div>
<p>The invocation will look like that:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EXPLAIN SELECT * FROM transactions 
WHERE created &lt; immutable_now(uuid_generate_v4());
</code></pre></div></div>


  </div><a class="u-url" href="/sql/2018/09/01/scanning-partition-tables.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Marek Hudyma&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Marek Hudyma</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/marekhudyma"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">marekhudyma</span></a></li><li><a href="/feed.xml"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#rss"></use></svg> <span>rss</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
