<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-10-09T23:52:32+02:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Marek Hudyma’s blog</title><subtitle></subtitle><author><name>Marek Hudyma</name></author><entry><title type="html">Database locking</title><link href="http://localhost:4000/sql/2018/10/01/database-locking.html" rel="alternate" type="text/html" title="Database locking" /><published>2018-10-01T00:00:00+02:00</published><updated>2018-10-01T00:00:00+02:00</updated><id>http://localhost:4000/sql/2018/10/01/database-locking</id><content type="html" xml:base="http://localhost:4000/sql/2018/10/01/database-locking.html">&lt;p&gt;In this article, you will find information on:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Optimistic read,&lt;/li&gt;
  &lt;li&gt;Pessimistic read,&lt;/li&gt;
  &lt;li&gt;Pessimistic write.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I will cover the topic in context of:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Hibernate with Spring,&lt;/li&gt;
  &lt;li&gt;PostgreSQL database (but it works in the same way on MySQL),&lt;/li&gt;
  &lt;li&gt;Isolation level - read commited,&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example of the working Java/SQL code you can find &lt;a href=&quot;https://github.com/marekhudyma/db-locking&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;why-do-you-need-locking-resource-in-database&quot;&gt;Why do you need locking resource in database&lt;/h1&gt;
&lt;p&gt;Lets say that you have two transactions that are overlapping:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Transaction 1 reads row,&lt;/li&gt;
  &lt;li&gt;Transaction 2 reads row,&lt;/li&gt;
  &lt;li&gt;Both transactions are modifying one column in the row,&lt;/li&gt;
  &lt;li&gt;Transaction 1 commits the changes&lt;/li&gt;
  &lt;li&gt;Transaction 2 commits the changes and &lt;strong&gt;overwrite&lt;/strong&gt; the changes from transaction 1.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
  &lt;img src=&quot;/assets/2018-10-01-database-locking/transactions_without_locking.png&quot; alt=&quot;Transactions without locking&quot; /&gt; 
  &lt;figcaption&gt;Transactions without locking&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;It can happen in many scenarios. Very common problem are two http requests or queue consumption comming one after another.&lt;/p&gt;

&lt;h1 id=&quot;how-to-add-locking&quot;&gt;How to add locking&lt;/h1&gt;
&lt;p&gt;To add locking to you JpaRepository you need to annotate the &lt;strong&gt;interface method&lt;/strong&gt; with @Lock annotation. Here is an example of PESSIMISTIC_WRITE:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Repository
public interface EntityRepository extends JpaRepository&amp;lt;Entity, Long&amp;gt; {

    @Lock(LockModeType.PESSIMISTIC_WRITE) 
    Optional&amp;lt;Entity&amp;gt; findById(Long id);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;If you annotate the method with body it will not work:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Repository
public interface EntityRepository extends JpaRepository&amp;lt;Entity, Long&amp;gt; {

    @Lock(LockModeType.PESSIMISTIC_WRITE)  // IT WILL NOT WORK 
    default Card findOneAndLock(String id) {
        return findOne(id);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Of course you can crete a native query with syntax “SELECT … FROM TABLE FOR UPDATE”.&lt;/p&gt;

&lt;h1 id=&quot;locking-types&quot;&gt;Locking types&lt;/h1&gt;

&lt;h2 id=&quot;none&quot;&gt;None&lt;/h2&gt;
&lt;p&gt;LockModeType.NONE is a default behaviour of JPA. It means there is no locking. 
Hibernate queries looks like that:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select entity_.created as created2_2_ from entity entity_ where entity_.id=?
update entity_without_version set created=?, description=? where id=?
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;optimistic-locking&quot;&gt;Optimistic locking&lt;/h2&gt;
&lt;p&gt;To LockModeType.OPTIMISTIC (synonym LockModeType.READ)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Annotate the method with @Lock(LockModeType.PESSIMISTIC_WRITE)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Add @Version field in your entity. Supported types:&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;int,&lt;/li&gt;
      &lt;li&gt;Integer,&lt;/li&gt;
      &lt;li&gt;short,&lt;/li&gt;
      &lt;li&gt;Short,&lt;/li&gt;
      &lt;li&gt;long,&lt;/li&gt;
      &lt;li&gt;Long,&lt;/li&gt;
      &lt;li&gt;java.sql.Timestamp&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If there is a different version of @Version field in the database, ObjectOptimisticLockingFailureException is thrown.&lt;/p&gt;

&lt;p&gt;select entitywith0&lt;em&gt;.id … from entity entity0&lt;/em&gt; where entity0_.id=?
update entity set created=?, description=?, version=? where id=? and version=?
The version has been updated: 
at the end of transaction
every time we call saveAndFlush&lt;/p&gt;

&lt;p&gt;The good source of information about optimistic lock is &lt;a href=&quot;https://www.baeldung.com/jpa-optimistic-locking&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt; If transaction T1 calls for a lock of type
&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;LockModeType.OPTIMISTIC&lt;/code&gt; on a versioned object,&lt;/li&gt;
  &lt;li&gt;the entity manager must ensure that neither of the following&lt;/li&gt;
  &lt;li&gt;phenomena can occur:&lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
&lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;li&gt; P1 (Dirty read): Transaction T1 modifies a row.
&lt;/li&gt;
  &lt;/li&gt;
  &lt;li&gt;Another transaction T2 then reads that row and obtains&lt;/li&gt;
  &lt;li&gt;the modified value, before T1 has committed or rolled back.&lt;/li&gt;
  &lt;li&gt;Transaction T2 eventually commits successfully; it does not&lt;/li&gt;
  &lt;li&gt;matter whether T1 commits or rolls back and whether it does&lt;/li&gt;
  &lt;li&gt;so before or after T2 commits.&lt;/li&gt;
  &lt;li&gt;
    &lt;li&gt;
&lt;/li&gt;
  &lt;/li&gt;
  &lt;li&gt;&amp;lt;/li&amp;gt; P2 (Non-repeatable read): Transaction T1 reads a row.&lt;/li&gt;
  &lt;li&gt;Another transaction T2 then modifies or deletes that row,&lt;/li&gt;
  &lt;li&gt;before T1 has committed. Both transactions eventually commit&lt;/li&gt;
  &lt;li&gt;successfully.&lt;/li&gt;
  &lt;li&gt;&amp;lt;/li&amp;gt;&lt;/li&gt;
  &lt;li&gt;&amp;lt;/ul&amp;gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;
&lt;p&gt;Table partitioning refers to splitting what is logically one large table into smaller physical pieces.&lt;/p&gt;

&lt;h2 id=&quot;methods-of-partitioning&quot;&gt;Methods of partitioning&lt;/h2&gt;
&lt;p&gt;There are two methods of data partitioning:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Horizontal partitioning&lt;/strong&gt; (involves putting different rows into different tables) - &lt;strong&gt;covered in this article&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
  &lt;img src=&quot;/assets/2018-08-01-postgreSQL-10-partitioning/horizontal.png&quot; alt=&quot;Horizontal partitioning&quot; /&gt; 
  &lt;figcaption&gt;Horizontal partitioning&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Vertical partitioning&lt;/strong&gt; (involves creating tables with fewer columns and using additional tables to store the remaining columns) - &lt;strong&gt;not covered in this article&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
  &lt;img src=&quot;/assets/2018-08-01-postgreSQL-10-partitioning/vertical.png&quot; alt=&quot;Vertical partitioning&quot; /&gt; 
  &lt;figcaption&gt;Vertical partitioning&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;benefits-of-partitioning&quot;&gt;Benefits of partitioning&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Your SQL search and update query &lt;strong&gt;performance&lt;/strong&gt; can be improved dramatically (smaller table needs to be scanned,  smaller index needs to be rebuilt).&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Bulk&lt;/strong&gt; loads and deletes can be accomplished by adding or removing partitions.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Seldom-used data&lt;/strong&gt; can be migrated to cheaper and slower storage media.&lt;/li&gt;
  &lt;li&gt;For frequently-used data, you can create &lt;strong&gt;sub-partitions&lt;/strong&gt; or composite partitions.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;types-of-horizontal-partitioning&quot;&gt;Types of horizontal partitioning&lt;/h2&gt;
&lt;p&gt;There are two built-in partitioning types:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Range partitioning&lt;/strong&gt; - The table is partitioned into “ranges” defined by a key column or set of columns, with no overlap between the ranges of values assigned to different partitions. For example, one might partition by date ranges or by ranges of identifiers for particular business objects.&lt;/li&gt;
  &lt;li&gt;List &lt;strong&gt;Partitioning&lt;/strong&gt; - The table is partitioned by explicitly listing which key values appear in each partition.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;postgresql-9-vs-postgresql-10-partitioning&quot;&gt;PostgreSQL 9 vs PostgreSQL 10 partitioning&lt;/h2&gt;
&lt;p&gt;Partitioning in PostgreSQL 9 was a nice improvement. Unfortunately, for Hibernate developers, it couldn’t be transparent. It required triggers that would put a row in the proper partition table. The problem was that it didn’t return the id of the inserted row and it couldn’t be mapped by Hibernate in a standard query. 
PostgreSQL 9 solution is faster than PostgreSQL 10 partitioning, but less convenient.&lt;/p&gt;

&lt;h2 id=&quot;implementing-partitions&quot;&gt;Implementing Partitions&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Create the “master” table.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- sequence will allow keeping the order of rows in all tables
CREATE SEQUENCE global_sequence START WITH 1 INCREMENT BY 10 
NO MINVALUE NO MAXVALUE CACHE 1;
#
CREATE TABLE transactions (
 sequence   BIGINT DEFAULT nextval('global_sequence'::regclass) NOT NULL,
 -- default value on created and updated so you can skip trigger for it
 created    TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT clock_timestamp(),
 updated    TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT clock_timestamp(),
 account_id UUID NOT NULL,
 amount     NUMERIC NOT NULL
) PARTITION BY RANGE (created);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Create partitions.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE transactions_2015 PARTITION OF transactions FOR VALUES 
FROM ('2015-01-01 00:00:00') TO ('2016-01-01 00:00:00');
#
CREATE TABLE transactions_2016 PARTITION OF transactions FOR VALUES 
FROM ('2016-01-01 00:00:00') TO ('2017-01-01 00:00:00');
# repeat for each partition table. 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Create an index on the key column(s) in each partition.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE ONLY transactions_2015 ADD CONSTRAINT 
transactions_2015_account_id_fkey FOREIGN KEY (account_id) 
REFERENCES accounts(id) ON UPDATE RESTRICT ON DELETE RESTRICT;
#
ALTER TABLE ONLY transactions_2016 ADD CONSTRAINT 
transactions_2016_account_id_fkey FOREIGN KEY (account_id) 
REFERENCES accounts(id) ON UPDATE RESTRICT ON DELETE RESTRICT;
# repeat for each partition table. 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Create foreign keys on column(s) in each partition.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE INDEX ON transactions_2015 (account_id);
CREATE INDEX ON transactions_2016 (account_id);
# repeat for each partition table. 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Create triggers in each partition.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TRIGGER set_updated_trigger BEFORE INSERT OR UPDATE ON 
transactions_2015 FOR EACH ROW EXECUTE PROCEDURE public.set_updated();
#
CREATE TRIGGER set_updated_trigger BEFORE INSERT OR UPDATE ON 
transactions_2016 FOR EACH ROW EXECUTE PROCEDURE public.set_updated();
# repeat for each partition table. 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;partition-limitations-in-postgresql-10&quot;&gt;Partition limitations in PostgreSQL 10&lt;/h2&gt;
&lt;p&gt;The main limitations are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;No global unique constraint (you can create it only on partition table level, not on master partition level);&lt;/li&gt;
  &lt;li&gt;No global row triggers, indexes;&lt;/li&gt;
  &lt;li&gt;No global primary and foreign keys;&lt;/li&gt;
  &lt;li&gt;No auto-creation of new partitions;&lt;/li&gt;
  &lt;li&gt;No update moves rows across partitions (you need to delete a row from one partition and create it in another);&lt;/li&gt;
  &lt;li&gt;Not possible to turn a regular table into a partitioned table or vice versa.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;global-uniqueness&quot;&gt;Global Uniqueness&lt;/h1&gt;
&lt;p&gt;Partitioned tables cannot yet be referenced by foreign constraints. This is due to the lack of global indexes (a.k.a. single indexes across all partitions) and has a profound impact on the design of a database: rendering it impossible to ensure global value uniqueness across all partitions, whether on a primary key or on a unique constraint.&lt;/p&gt;

&lt;p&gt;Global indexes will be introduced in PostgreSQL 11, and in the meantime, the following three workarounds are the only viable ones:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Have a secondary non-partitioned table where the unique constraints are defined and that only contains the columns involved in those constraints.&lt;/li&gt;
  &lt;li&gt;If there are no concurrency concerns, let the application check beforehand for the existence of an entry with the same key before insertion (scan of the table aided by partition routing and proper indexes defined on the single partitions). This works only with isolation &lt;code class=&quot;highlighter-rouge&quot;&gt;READ COMMITTED&lt;/code&gt; level.&lt;/li&gt;
  &lt;li&gt;If there are concurrency concerns and there is a guarantee that uniqueness could only be violated within one account (or user), another table that contains all accounts could be used for locking this particular account with &lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT FOR UPDATE&lt;/code&gt; for the duration of the transaction. This also works only with isolation &lt;code class=&quot;highlighter-rouge&quot;&gt;READ COMMITTED&lt;/code&gt; level. &lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT FOR UPDATE&lt;/code&gt; can’t be normally used on the partitioned table, because the row that needs to be locked may not exist.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unfortunately, all of these approaches partially invalidate the gains in terms of the performance and scalability introduced by partitioning, but it will at least lay the foundations for a proper design to be improved once PostgreSQL 11 is available.&lt;/p&gt;

&lt;h2 id=&quot;useful-advice&quot;&gt;Useful advice&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Do not go overboard with partitioning, only important tables.&lt;/li&gt;
  &lt;li&gt;Do it table by table.&lt;/li&gt;
  &lt;li&gt;Test partitions with integration tests (check whether a row is in a proper partition).&lt;/li&gt;
  &lt;li&gt;The popular idea for partitioning is DATETIME and having BIGINT as a primary key. From a theoretical point of view, it is possible that the last row in the older partition will have a higher primary key than the first row in the newer partition. It is a good idea to add an additional constraint on the partition on the primary key when you stop actively write to partition.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;when-to-do-partitioning&quot;&gt;When to do partitioning&lt;/h2&gt;
&lt;p&gt;For the question: how many rows should my table contain to partition it?
I always hear: It &lt;code class=&quot;highlighter-rouge&quot;&gt;depends&lt;/code&gt;. 
But if I need to give some &lt;code class=&quot;highlighter-rouge&quot;&gt;magic number&lt;/code&gt;, I would say: &lt;code class=&quot;highlighter-rouge&quot;&gt;10 million in the whole history of the table&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;postgresql-11-features&quot;&gt;PostgreSQL 11 features&lt;/h2&gt;
&lt;p&gt;PostgreSQL is planned for release in autumn 2018. &lt;a href=&quot;https://www.postgresql.org/docs/11/static/release-11.html&quot;&gt;Here&lt;/a&gt; is a full list of the most important features from a partitioning point of view:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Update Moves Rows Across Partitions&lt;/li&gt;
  &lt;li&gt;Unique index on the master table&lt;/li&gt;
  &lt;li&gt;Default Partition table&lt;/li&gt;
  &lt;li&gt;Partition by Hash
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE my_table (some_field text) PARTITION BY HASH (some_field);
CREATE TABLE my_table_0 PARTITION OF my_table 
FOR VALUES WITH (MODULUS 3, REMAINDER 0);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;alternative-solutions&quot;&gt;Alternative solutions&lt;/h2&gt;
&lt;p&gt;As an alternative to partitioning, you may consider using &lt;a href=&quot;https://en.wikipedia.org/wiki/Shard_(database_architecture)&quot;&gt;sharding&lt;/a&gt; or both: partitioning and sharding.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Partitioning in PostgreSQL 10 allows Java developers (Hibernate users) to easily and transparently map partitioned tables to a Java object. It still has some drawbacks, like repeated code to create indexes, foreign keys, etc. PostgreSQL 11 seems to be a nice improvement. The release cycle of Postgres is speeding up, so the new version will be available soon.&lt;/p&gt;</content><author><name>Marek Hudyma</name></author><summary type="html">In this article, you will find information on: Optimistic read, Pessimistic read, Pessimistic write.</summary></entry><entry><title type="html">Scanning partitioned tables in PostgreSQL 10</title><link href="http://localhost:4000/sql/2018/09/01/scanning-partition-tables.html" rel="alternate" type="text/html" title="Scanning partitioned tables in PostgreSQL 10" /><published>2018-09-01T00:00:00+02:00</published><updated>2018-09-01T00:00:00+02:00</updated><id>http://localhost:4000/sql/2018/09/01/scanning-partition-tables</id><content type="html" xml:base="http://localhost:4000/sql/2018/09/01/scanning-partition-tables.html">&lt;p&gt;In this article, you will find information on:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;How to scan partitioned tables in Postgres using function &lt;code class=&quot;highlighter-rouge&quot;&gt;now()&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;scanning-partitioned-tables&quot;&gt;Scanning partitioned tables&lt;/h1&gt;
&lt;p&gt;In my application, I wanted to get rows older than the current time. 
I executed the explain plan for the query and I realized that the execution plan did not eliminate unnecessary partitions:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;EXPLAIN SELECT * FROM transactions WHERE created &amp;lt; now();  -- it is 2018-08-01
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;figure&gt;
  &lt;img src=&quot;/assets/2018-09-01-scanning-partition-tables/execution_plan_now.png&quot; alt=&quot;Execution plan for now function&quot; /&gt; 
  &lt;figcaption&gt;not optimal execution plan&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;I was surprised that DB didn’t make this query optimal. Execution with the hardcoded value returned optimal execution plan:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;EXPLAIN SELECT * FROM transactions WHERE created &amp;lt; '2018-01-01 00:00:00'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;figure&gt;
  &lt;img src=&quot;/assets/2018-09-01-scanning-partition-tables/execution_plan_static_date.png&quot; alt=&quot;Execution plan for static date&quot; /&gt; 
  &lt;figcaption&gt;optimal execution plan&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;The reason is that function &lt;code class=&quot;highlighter-rouge&quot;&gt;now()&lt;/code&gt; is not immutable. 
Constant values for the timestamps in the WHERE clause of the query work as expected but if the comparison is against a non-immutable function (such as now(), current_time, current_date, clock_timestamp(), etc.) then the query optimizer won’t be able to narrow down the scan to the relevant partitions, since it doesn’t know in which one the function value will fall into at runtime. It will, therefore, fall back to a full scan of all partitions removing the benefit of partitioning.&lt;/p&gt;

&lt;p&gt;With this knowledge, I defined the function that returns &lt;code class=&quot;highlighter-rouge&quot;&gt;immutable now&lt;/code&gt; :&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE FUNCTION immutable_now() RETURNS  TIMESTAMP WITH TIME ZONE AS $$
    SELECT now();
$$ LANGUAGE sql IMMUTABLE;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;It seemed to work correctly! Rows were returned correctly, but suddenly it stopped returning newer rows.
The reason is that PostgreSQL started to &lt;code class=&quot;highlighter-rouge&quot;&gt;cache the results of the immutable_now&lt;/code&gt; function.&lt;/p&gt;
&lt;figure&gt;
  &lt;img src=&quot;/assets/2018-09-01-scanning-partition-tables/flow_diagram.png&quot; alt=&quot;Flow diagram&quot; /&gt; 
  &lt;figcaption&gt;PostgreSQL started to cache the result of the immutable_now function.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h1 id=&quot;reason&quot;&gt;Reason&lt;/h1&gt;
&lt;p&gt;Documentation on &lt;a href=&quot;https://www.postgresql.org/docs/current/static/sql-createfunction.html&quot;&gt;function immutability&lt;/a&gt;:
&lt;em&gt;“IMMUTABLE indicates that the function […] always returns the same result when given the same argument values; that is, it does not […] use information not directly present in its argument list. If this option is given, any call of the function with all-constant arguments can be immediately replaced with the function value.”&lt;/em&gt;
`
and again in the documentation on function &lt;a href=&quot;https://www.postgresql.org/docs/current/static/xfunc-volatility.html&quot;&gt;volatility categories&lt;/a&gt;
&lt;em&gt;“Labeling a function IMMUTABLE when it really isn’t might allow it to be prematurely folded to a constant during planning, resulting in a stale value being re-used during subsequent uses of the plan. This is a hazard when using […] function languages that cache plans (such as PL/pgSQL).”&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;solution&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;The solution was to add random UUID as an argument, that will be ignored. PostgreSQL will not cache this function:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE FUNCTION immutable_now(ignored uuid) RETURNS TIMESTAMP WITH TIME ZONE AS 
$$
    SELECT now();
$$ LANGUAGE sql IMMUTABLE;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The invocation will look like that:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;EXPLAIN SELECT * FROM transactions 
WHERE created &amp;lt; immutable_now(uuid_generate_v4());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Marek Hudyma</name></author><summary type="html">In this article, you will find information on: How to scan partitioned tables in Postgres using function now().</summary></entry><entry><title type="html">PostgreSQL 10 table partitioning</title><link href="http://localhost:4000/sql/2018/08/01/postgreSQL-10-partitioning.html" rel="alternate" type="text/html" title="PostgreSQL 10 table partitioning" /><published>2018-08-01T00:00:00+02:00</published><updated>2018-08-01T00:00:00+02:00</updated><id>http://localhost:4000/sql/2018/08/01/postgreSQL-10-partitioning</id><content type="html" xml:base="http://localhost:4000/sql/2018/08/01/postgreSQL-10-partitioning.html">&lt;p&gt;In this article, you will find information on:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;What is partitioning&lt;/li&gt;
  &lt;li&gt;How to implement partitioning&lt;/li&gt;
  &lt;li&gt;Which problems I found using PostgreSQL 10 table partitioning.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example of the working Java/SQL code you can find &lt;a href=&quot;https://github.com/marekhudyma/partitioning&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;
&lt;p&gt;Table partitioning refers to splitting what is logically one large table into smaller physical pieces.&lt;/p&gt;

&lt;h2 id=&quot;methods-of-partitioning&quot;&gt;Methods of partitioning&lt;/h2&gt;
&lt;p&gt;There are two methods of data partitioning:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Horizontal partitioning&lt;/strong&gt; (involves putting different rows into different tables) - &lt;strong&gt;covered in this article&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
  &lt;img src=&quot;/assets/2018-08-01-postgreSQL-10-partitioning/horizontal.png&quot; alt=&quot;Horizontal partitioning&quot; /&gt; 
  &lt;figcaption&gt;Horizontal partitioning&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Vertical partitioning&lt;/strong&gt; (involves creating tables with fewer columns and using additional tables to store the remaining columns) - &lt;strong&gt;not covered in this article&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
  &lt;img src=&quot;/assets/2018-08-01-postgreSQL-10-partitioning/vertical.png&quot; alt=&quot;Vertical partitioning&quot; /&gt; 
  &lt;figcaption&gt;Vertical partitioning&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;benefits-of-partitioning&quot;&gt;Benefits of partitioning&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Your SQL search and update query &lt;strong&gt;performance&lt;/strong&gt; can be improved dramatically (smaller table needs to be scanned,  smaller index needs to be rebuilt).&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Bulk&lt;/strong&gt; loads and deletes can be accomplished by adding or removing partitions.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Seldom-used data&lt;/strong&gt; can be migrated to cheaper and slower storage media.&lt;/li&gt;
  &lt;li&gt;For frequently-used data, you can create &lt;strong&gt;sub-partitions&lt;/strong&gt; or composite partitions.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;types-of-horizontal-partitioning&quot;&gt;Types of horizontal partitioning&lt;/h2&gt;
&lt;p&gt;There are two built-in partitioning types:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Range partitioning&lt;/strong&gt; - The table is partitioned into “ranges” defined by a key column or set of columns, with no overlap between the ranges of values assigned to different partitions. For example, one might partition by date ranges or by ranges of identifiers for particular business objects.&lt;/li&gt;
  &lt;li&gt;List &lt;strong&gt;Partitioning&lt;/strong&gt; - The table is partitioned by explicitly listing which key values appear in each partition.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;postgresql-9-vs-postgresql-10-partitioning&quot;&gt;PostgreSQL 9 vs PostgreSQL 10 partitioning&lt;/h2&gt;
&lt;p&gt;Partitioning in PostgreSQL 9 was a nice improvement. Unfortunately, for Hibernate developers, it couldn’t be transparent. It required triggers that would put a row in the proper partition table. The problem was that it didn’t return the id of the inserted row and it couldn’t be mapped by Hibernate in a standard query. 
PostgreSQL 9 solution is faster than PostgreSQL 10 partitioning, but less convenient.&lt;/p&gt;

&lt;h2 id=&quot;implementing-partitions&quot;&gt;Implementing Partitions&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Create the “master” table.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- sequence will allow keeping the order of rows in all tables
CREATE SEQUENCE global_sequence START WITH 1 INCREMENT BY 10 
NO MINVALUE NO MAXVALUE CACHE 1;
#
CREATE TABLE transactions (
 sequence   BIGINT DEFAULT nextval('global_sequence'::regclass) NOT NULL,
 -- default value on created and updated so you can skip trigger for it
 created    TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT clock_timestamp(),
 updated    TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT clock_timestamp(),
 account_id UUID NOT NULL,
 amount     NUMERIC NOT NULL
) PARTITION BY RANGE (created);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Create partitions.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE transactions_2015 PARTITION OF transactions FOR VALUES 
FROM ('2015-01-01 00:00:00') TO ('2016-01-01 00:00:00');
#
CREATE TABLE transactions_2016 PARTITION OF transactions FOR VALUES 
FROM ('2016-01-01 00:00:00') TO ('2017-01-01 00:00:00');
# repeat for each partition table. 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Create foreign keys on column(s) in each partition.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE ONLY transactions_2015 ADD CONSTRAINT 
transactions_2015_account_id_fkey FOREIGN KEY (account_id) 
REFERENCES accounts(id) ON UPDATE RESTRICT ON DELETE RESTRICT;
#
ALTER TABLE ONLY transactions_2016 ADD CONSTRAINT 
transactions_2016_account_id_fkey FOREIGN KEY (account_id) 
REFERENCES accounts(id) ON UPDATE RESTRICT ON DELETE RESTRICT;
# repeat for each partition table. 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Create an index on the key column(s) in each partition.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE INDEX ON transactions_2015 (account_id);
CREATE INDEX ON transactions_2016 (account_id);
# repeat for each partition table. 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Create triggers in each partition.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TRIGGER set_updated_trigger BEFORE INSERT OR UPDATE ON 
transactions_2015 FOR EACH ROW EXECUTE PROCEDURE public.set_updated();
#
CREATE TRIGGER set_updated_trigger BEFORE INSERT OR UPDATE ON 
transactions_2016 FOR EACH ROW EXECUTE PROCEDURE public.set_updated();
# repeat for each partition table. 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;partition-limitations-in-postgresql-10&quot;&gt;Partition limitations in PostgreSQL 10&lt;/h2&gt;
&lt;p&gt;The main limitations are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;No global unique constraint (you can create it only on partition table level, not on master partition level);&lt;/li&gt;
  &lt;li&gt;No global row triggers, indexes;&lt;/li&gt;
  &lt;li&gt;No global primary and foreign keys;&lt;/li&gt;
  &lt;li&gt;No auto-creation of new partitions;&lt;/li&gt;
  &lt;li&gt;No update moves rows across partitions (you need to delete a row from one partition and create it in another);&lt;/li&gt;
  &lt;li&gt;Not possible to turn a regular table into a partitioned table or vice versa.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;global-uniqueness&quot;&gt;Global Uniqueness&lt;/h1&gt;
&lt;p&gt;Partitioned tables cannot yet be referenced by foreign constraints. This is due to the lack of global indexes (a.k.a. single indexes across all partitions) and has a profound impact on the design of a database: rendering it impossible to ensure global value uniqueness across all partitions, whether on a primary key or on a unique constraint.&lt;/p&gt;

&lt;p&gt;Global indexes will be introduced in PostgreSQL 11, and in the meantime, the following three workarounds are the only viable ones:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Have a secondary non-partitioned table where the unique constraints are defined and that only contains the columns involved in those constraints.&lt;/li&gt;
  &lt;li&gt;If there are no concurrency concerns, let the application check beforehand for the existence of an entry with the same key before insertion (scan of the table aided by partition routing and proper indexes defined on the single partitions). This works only with isolation &lt;code class=&quot;highlighter-rouge&quot;&gt;READ COMMITTED&lt;/code&gt; level.&lt;/li&gt;
  &lt;li&gt;If there are concurrency concerns and there is a guarantee that uniqueness could only be violated within one account (or user), another table that contains all accounts could be used for locking this particular account with &lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT FOR UPDATE&lt;/code&gt; for the duration of the transaction. This also works only with isolation &lt;code class=&quot;highlighter-rouge&quot;&gt;READ COMMITTED&lt;/code&gt; level. &lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT FOR UPDATE&lt;/code&gt; can’t be normally used on the partitioned table, because the row that needs to be locked may not exist.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unfortunately, all of these approaches partially invalidate the gains in terms of the performance and scalability introduced by partitioning, but it will at least lay the foundations for a proper design to be improved once PostgreSQL 11 is available.&lt;/p&gt;

&lt;h2 id=&quot;useful-advice&quot;&gt;Useful advice&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Do not go overboard with partitioning, only important tables.&lt;/li&gt;
  &lt;li&gt;Do it table by table.&lt;/li&gt;
  &lt;li&gt;Test partitions with integration tests (check whether a row is in a proper partition).&lt;/li&gt;
  &lt;li&gt;The popular idea for partitioning is DATETIME and having BIGINT as a primary key. From a theoretical point of view, it is possible that the last row in the older partition will have a higher primary key than the first row in the newer partition. It is a good idea to add an additional constraint on the partition on the primary key when you stop actively write to partition.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;when-to-do-partitioning&quot;&gt;When to do partitioning&lt;/h2&gt;
&lt;p&gt;For the question: how many rows should my table contain to partition it?
I always hear: It &lt;code class=&quot;highlighter-rouge&quot;&gt;depends&lt;/code&gt;. 
But if I need to give some &lt;code class=&quot;highlighter-rouge&quot;&gt;magic number&lt;/code&gt;, I would say: &lt;code class=&quot;highlighter-rouge&quot;&gt;10 million in the whole history of the table&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;postgresql-11-features&quot;&gt;PostgreSQL 11 features&lt;/h2&gt;
&lt;p&gt;PostgreSQL is planned for release in autumn 2018. &lt;a href=&quot;https://www.postgresql.org/docs/11/static/release-11.html&quot;&gt;Here&lt;/a&gt; is a full list of the most important features from a partitioning point of view:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Update Moves Rows Across Partitions&lt;/li&gt;
  &lt;li&gt;Unique index on the master table&lt;/li&gt;
  &lt;li&gt;Default Partition table&lt;/li&gt;
  &lt;li&gt;Partition by Hash
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE my_table (some_field text) PARTITION BY HASH (some_field);
CREATE TABLE my_table_0 PARTITION OF my_table 
FOR VALUES WITH (MODULUS 3, REMAINDER 0);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;alternative-solutions&quot;&gt;Alternative solutions&lt;/h2&gt;
&lt;p&gt;As an alternative to partitioning, you may consider using &lt;a href=&quot;https://en.wikipedia.org/wiki/Shard_(database_architecture)&quot;&gt;sharding&lt;/a&gt; or both: partitioning and sharding.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Partitioning in PostgreSQL 10 allows Java developers (Hibernate users) to easily and transparently map partitioned tables to a Java object. It still has some drawbacks, like repeated code to create indexes, foreign keys, etc. PostgreSQL 11 seems to be a nice improvement. The release cycle of Postgres is speeding up, so the new version will be available soon.&lt;/p&gt;</content><author><name>Marek Hudyma</name></author><summary type="html">In this article, you will find information on: What is partitioning How to implement partitioning Which problems I found using PostgreSQL 10 table partitioning.</summary></entry></feed>